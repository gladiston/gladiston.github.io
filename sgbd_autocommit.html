<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autocommit: Pr√≥s e Contras - Gladiston Santana</title>
    <link rel="stylesheet" href="css/estilo.css">
</head>
<body>
    <header class="main-header">
        <div class="header-container">
            <img src="assets/img/logo.jpg" alt="Logo" class="logo-circle">
            <div class="header-text">
                <h1>Transa√ß√µes e Autocommit</h1>
                <p>O impacto do commit autom√°tico na integridade e no desempenho.</p>
            </div>
        </div>
    </header>

    <nav class="main-nav">
        <ul class="nav-links">
            <li><a href="index.html">In√≠cio</a></li>
            <li><a href="sgbd.html">Voltar para SGBD</a></li>
        </ul>
    </nav>

    <main>
        <article>
            <h2>O que √© o Autocommit?</h2>
            <p>A maioria das su√≠tes de conex√£o ao banco de dados para Delphi ou Lazarus, como FireDAC, ZeosDBO, SQLdb etc., ao se conectar a uma base de dados, possui uma propriedade chamada <strong>autocommit</strong>. Ela pode estar ligada (true) ou desligada (false).</p>

            <p>Para explicar como funciona, precisamos entender o que √© uma transa√ß√£o. Neste contexto, uma transa√ß√£o √© um per√≠odo em que iniciamos uma s√©rie de modifica√ß√µes no banco de dados, que deve ser encerrada com um commit ‚Äî a confirma√ß√£o de que tudo o que foi feito desde o in√≠cio da transa√ß√£o deve ser mantido ‚Äî ou com um rollback ‚Äî desfazer toda a transa√ß√£o desde o seu in√≠cio.</p>

            <p>Ent√£o, o que o <strong>autocommit</strong> faz ao estar ligado √© tornar ‚Äúiniciar uma transa√ß√£o‚Äù opcional ao programador. Por√©m, por baixo dos panos, a su√≠te de acesso a dados criar√° uma transa√ß√£o para voc√™ antes de executar o seu statement e a finalizar√° com um commit. Isso d√° ao programador a impress√£o de que, a partir de agora, n√£o precisar√° mais se preocupar com iniciar e finalizar transa√ß√µes.</p>

            <h3>O Problema da Atomicidade</h3>
            <p>Imagine uma transfer√™ncia banc√°ria: voc√™ precisa tirar dinheiro de uma conta e colocar em outra. No modo Autocommit, se o sistema falhar entre as duas opera√ß√µes, o dinheiro "desaparece". Sem o controle manual de transa√ß√£o, voc√™ perde a <strong>Atomicidade</strong> (o "A" do ACID).</p>

            <h3>Impacto na Performance</h3>
            <p>Escrever no disco √© caro. No modo Autocommit, o banco √© for√ßado a gravar fisicamente o log de transa√ß√£o a cada comando. Ao agrupar 1000 inser√ß√µes em uma √∫nica transa√ß√£o manual, a performance pode ser at√© 10x superior.</p>

            <p>No v√≠deo abaixo, eu demonstro que uma transfer√™ncia de 10.000 registros com autocommit ligado e desligado tem diferen√ßas absurdas de tempo. Por qu√™? Porque, com o autocommit desligado, voc√™ inicia uma transa√ß√£o uma √∫nica vez, faz a transfer√™ncia de 10.000 registros e, depois, d√° commit. Por√©m, com o autocommit ligado, o que acontece de diferente √©: inicia uma transa√ß√£o, transfere um registro e, ent√£o, d√° commit; depois repete a mesma opera√ß√£o com o segundo, o terceiro... at√© o √∫ltimo registro, executando 10.000 transa√ß√µes. Como resultado, o autocommit ligado torna as coisas muito, mas muito lentas quando as opera√ß√µes s√£o feitas em lote.</p>

            <pre><code>-- EVITE O AUTOCOMMIT EM OPERA√á√ïES EM LOTE
START TRANSACTION;
INSERT INTO VENDAS ...;
INSERT INTO ITENS_VENDA ...;
-- Se tudo correr bem:
COMMIT;
-- Se algo falhar:
ROLLBACK;</code></pre>

            <h2>StartTransaction: A V√°lvula de Escape</h2>
            
            <p>Algo importante a se dizer √© que o autocommit ligado em ferramentas como Zeos ou FireDAC tem uma v√°lvula de escape: se voc√™ der um <code>StartTransaction</code>, a su√≠te entende que, para esta opera√ß√£o, o autocommit ser√° falso, e voc√™ ter√° de terminar manualmente a transa√ß√£o usando commit (ou rollback). Isso √© muito bom para o programador, porque ele contorna poss√≠veis problemas de n√£o ter iniciado uma transa√ß√£o e, caso inicie, ter√° m√°ximo desempenho por escolher onde dar o commit.</p>

            <div class="warning-box">
                <strong>ATEN√á√ÉO: Comportamento do StartTransaction</strong>
                <p>No Zeos e no FireDAC, quando voc√™ chama <code>conn.StartTransaction</code>, a su√≠te <strong>interrompe o autocommit</strong> at√© que ocorra um commit/rollback expl√≠cito. Mas aten√ß√£o: se o seu fluxo de transa√ß√£o n√£o terminar em commit/rollback, vai dar um xab√∫ que n√£o tem tamanho, pois a transa√ß√£o vai encapsular tudo o que vier depois.</p>
                
                <p>Quando voc√™ vir uma hist√≥ria de algu√©m dizendo que o sistema ‚Äúperdeu tudo‚Äù no fim do dia ou que registros est√£o sumindo, geralmente √© disso que estamos falando. A transa√ß√£o come√ßou e, de in√≠cio, n√£o houve commit nem rollback... da√≠ os dados foram acontecendo depois e, em outro ponto do programa, um <code>try...except</code> deu um rollback, mas n√£o voltou apenas naquele ponto: voltou desde o primeiro <code>StartTransaction</code> que n√£o teve commit/rollback.</p>
                
                <p><strong>Por isso, try..except para come√ßar e terminar uma transa√ß√£o √© mandat√≥rio: se a transa√ß√£o come√ßou, ningu√©m sai do bloco com ela ativa (sem commit/rollback).</strong></p>
            </div>

            <h3>Exemplo Correto: Usando Try..Except</h3>
            
            <p>Veja como deve ser feito corretamente:</p>

            <pre><code>// Exemplo com Zeos (padr√£o recomendado)
// - N√£o engole a exce√ß√£o (mant√©m contexto)
// - Garante que, SE a transa√ß√£o iniciou, ela termina em Commit/Rollback
ZConnection1.StartTransaction;
try
  // Suas opera√ß√µes aqui
  Query1.ExecSQL;
  Query2.ExecSQL;

  // Se tudo correr bem
  ZConnection1.Commit;
except
  // Se algo der errado, desfaz somente o que est√° nessa transa√ß√£o
  if ZConnection1.InTransaction then
    ZConnection1.Rollback;
  raise; // Relan√ßa a exce√ß√£o para ser tratada fora
end;</code></pre>

            <pre><code>// Exemplo com FireDAC (padr√£o recomendado)
// - N√£o engole a exce√ß√£o (mant√©m contexto)
// - Garante que, SE a transa√ß√£o iniciou, ela termina em Commit/Rollback
FDConnection1.StartTransaction;
try
  // Suas opera√ß√µes aqui
  FDQuery1.ExecSQL;
  FDQuery2.ExecSQL;

  // Se tudo correr bem
  FDConnection1.Commit;
except
  // Se algo der errado, desfaz somente o que est√° nessa transa√ß√£o
  if FDConnection1.InTransaction then
    FDConnection1.Rollback;
  raise; // Relan√ßa a exce√ß√£o para ser tratada fora
end;</code></pre>

            <div class="warning-box">
                <strong>üö® Erro Comum: Transa√ß√£o Aberta Sem Fechamento</strong>
                <p>Nunca fa√ßa isso:</p>
                <pre><code>// ERRADO - NUNCA FA√áA ISSO!
ZConnection1.StartTransaction;
Query1.ExecSQL;
// Se algo der errado aqui, a transa√ß√£o fica aberta!
Query2.ExecSQL;
ZConnection1.Commit;</code></pre>
                
                <p>Se <code>Query2.ExecSQL</code> lan√ßar uma exce√ß√£o, o <code>Commit</code> nunca ser√° executado e a transa√ß√£o ficar√° aberta, encapsulando todas as opera√ß√µes subsequentes at√© que a conex√£o seja fechada ou um rollback seja executado em outro ponto do c√≥digo (possivelmente causando perda de dados leg√≠timos).</p>
            </div>

            <h2>Por que √© importante saber disso?</h2>
            
            <p>Por que √© importante conhecer a su√≠te de acesso a banco de dados e suas propriedades, como o autocommit? Porque, em situa√ß√µes de lentid√£o no acesso √† base de dados, a culpa vira ‚Äúo servidor est√° lento‚Äù ou ‚Äúo banco de dados √© lento‚Äù, quando, na realidade, √© desconhecimento da ferramenta.</p>

            <h2>Conclus√£o</h2>
            
            <p>O Autocommit √© aceit√°vel para consultas r√°pidas (SELECT) ou testes simples via terminal. Para aplica√ß√µes reais, o controle transacional expl√≠cito √© o que separa um sistema amador de um software corporativo robusto.</p>

            <p><strong>Lembre-se sempre:</strong> Quando usar <code>StartTransaction</code>, sempre envolva em <code>try..except</code> garantindo que, <strong>se a transa√ß√£o estiver ativa</strong>, haver√° <strong>Commit</strong> ou <strong>Rollback</strong>. Isso evita problemas catastr√≥ficos de perda de dados ou transa√ß√µes √≥rf√£s que podem afetar todo o sistema.</p>

            <p><a href="sgbd.html" class="back-link">&larr; Voltar para SGBD</a></p>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Gladiston Santana. S√£o Paulo, Brasil.</p>
    </footer>
</body>
</html>
