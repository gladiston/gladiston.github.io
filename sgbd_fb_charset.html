<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qual charset devo usar? ISO8859_1, WIN1252 ou UNICODE? - Gladiston Santana</title>
    <link rel="stylesheet" href="css/estilo.css">
</head>
<body>

    <header class="main-header">
        <div class="header-container">
            <img src="assets/img/logo.jpg" alt="Logo" class="logo-circle">
            <div class="header-text">
                <h1>Qual charset devo usar?</h1>
                <p><code>ISO8859_1</code>, <code>WIN1252</code> ou <code>UNICODE</code>? - Guia completo para FirebirdSQL</p>
            </div>
        </div>
    </header>

    <nav class="main-nav">
        <ul class="nav-links">
            <li><a href="index.html">Início</a></li>
            <li><a href="sgbd.html">SGBD Hub</a></li>
            <li><a href="sgbd_fb_intro.html">Firebird</a></li>
        </ul>
    </nav>

    <main>
        <article>
            <h2>Por que essa pergunta é importante?</h2>
            
            <p>Se você usa o Windows, deve estar se perguntando por que essa pergunta é importante. 
                Por gentileza, abra o cmd e execute comigo o comando "chcp", ele retorna o código de página de caracteres que está em uso no momento:</p>  
                <img src="assets/img/sgbd_fb_charset01.png" alt="Código de página de caracteres"><br>
            <p>Ele retornará o código de página <b>850</b>.</p>

            <p>Vamos ao Google e pesquisar esta página com os termos "Code page 850" e seremos encaminhados para a Wikipedia:</p>
            <p><a href="https://en.wikipedia.org/wiki/Code_page_850" target="_blank">https://en.wikipedia.org/wiki/Code_page_850</a></p>

            <p>E então descobrimos que estamos usando o <code>ISO8859_1</code> (também conhecido como "Latin1").</p>

            <h2>Histórico: <code>ISO8859_1</code>, <code>WIN1252</code> e <code>UNICODE</code></h2>

            <p>Se você chegou a conhecer o MS-DOS deve se lembrar do comando <code>chcp</code> que usávamos no <code>autoexec.bat</code> para tornar possível ver as acentuações na tela. Então desde os primórdios do MS-DOS usamos <code>ISO8859_1</code> para tornar possível ver nossas acentuações no terminal. O <code>ISO8859_1</code> leva o prefixo "iso" porque foi aprovado pelo comitê internacional de mesmo nome: International Organization for Standardization (Organização Internacional de Normalização) o equivalente a nossa ABNT só que internacional.</p>

            <p>Mas uma coisa é o terminal, algo considerado legado por alguns para rodar aplicações. Quando o Windows surgiu com uma interface gráfica, a Microsoft resolveu criar um novo código de página chamado <code>WIN1252</code>; por isso tem o "Win" no nome, foi feito exclusivamente para o ambiente Windows e teve a aprovação da ANSI, a ABNT americana.</p>

            <p>Por que criar seu próprio padrão ao invés de continuar usando o <code>ISO8859_1</code>? Essa é uma pergunta difícil de responder. O <code>ISO8859_1</code> foi criado inicialmente pela Apple e depois aprovado pela ISO, e naquela época a Microsoft gostava de ditar os padrões da indústria; talvez por isso tenham criado o <code>WIN1252</code>. Ele deveria ser desnecessário, já que teve como base o próprio <code>ISO8859_1</code> e ambos, com poucas exceções, são intercambiáveis entre si. Pessoalmente, só conheço duas diferenças entre ambos: o <code>WIN1252</code> possui um travessão longo que é diferente do traço normal e um jogo de aspas com serifa (curva).</p>

            <h2>O problema da fragmentação no Windows</h2>

            <p>Ter um padrão de geração de caracteres diferentes só criou problemas para a Microsoft: seu terminal (cmd) usa <code>ISO8859_1</code>, a interface gráfica é <code>WIN1252</code>, o sistema de arquivos é <code>UNICODE</code>. Há pouco tempo, se você usasse um bloco de notas para editar um arquivo PHP ou HTML, tinha boas chances de ter o seu trabalho perdido. Sistemas como o Linux são tudo <code>UNICODE</code> e normalmente não é preciso lidar com conversões entre código de páginas diferentes.</p>

            <p>Um outro problema com o ambiente Windows é que ele não é mais tão universal como antes; hoje as aplicações estão em nuvem e a maioria dos serviços de banco de dados são hospedados em computadores que não rodam Windows. Se você hospedar dados num servidor Windows armazenando dados no formato <code>WIN1252</code>, provavelmente teria de pensar o que aconteceria se resolvesse hospedar um banco de dados num sistema operacional Linux que segue apenas padrões internacionais ISO, onde o <code>WIN1252</code> não existe. Você talvez tenha de lidar com problemas de transliteração de caracteres.</p>

            <div class="info-box">
                <strong>Dica:</strong> Para demonstrar essa transliteração, você pode usar o Notepad++ para visualizar como os mesmos caracteres são interpretados de forma diferente dependendo da codificação escolhida.
            </div>

            <h2>Recomendação: <code>ISO8859_1</code> para portabilidade</h2>

            <p>Então, o desejável, se queremos uma aplicação ou banco de dados que seja portável entre sistemas operacionais, é desistir do <code>WIN1252</code> e, em seu lugar, optar pelo <code>ISO8859_1</code>. Agora, daqui em diante vou falar apenas do <code>ISO8859_1</code> e o padrão <code>UNICODE</code>. Mas ao me referir ao <code>ISO8859_1</code>, lembre-se que também é aplicável ao <code>WIN1252</code>.</p>

            <h2><code>UNICODE</code>: a solução moderna</h2>

            <p>O <code>UNICODE</code> veio para resolver alguns problemas. Há uma ótima palestra da Firebird Conference 2011 em Luxembourg onde o palestrante falou muito sobre charsets, na sua palestra intitulada "Character Sets and Unicode in Firebird" e citou as vantagens:</p>

            <p><strong>Referência:</strong> <a href="https://www.firebirdsql.org/file/community/ppts/fbcon11/FbCon2011-Charsets-Heymann.pdf" target="_blank">https://www.firebirdsql.org/file/community/ppts/fbcon11/FbCon2011-Charsets-Heymann.pdf</a></p>

            <ul>
                <li>Um único conjunto de caracteres para todos os idiomas / scripts</li>
                <li>Sem sobreposições de código, não é necessário um código arbitrário para corrigir incongruências</li>
                <li>Independente de hardware e sistema operacional</li>
            </ul>

            <h3>Testando no terminal do Windows</h3>

            <p>Vamos comprovar que estamos usando o <code>ISO8859_1</code>; vamos agora mudar para <code>WIN1252</code>:</p>

            <pre><code>chcp 1252
echo linha #1: teste com com página iso8859_1>teste.txt
echo linha #2: atenção, minha acentuação é inoqüa>>teste.txt
hexeditor teste.txt</code></pre>

            <p>Parece tudo certo, né? Mas vamos mudar agora o código da página para <code>UNICODE</code>:</p>

            <pre><code>chcp 65001
echo linha #3: teste com com página unicode>>teste.txt
echo linha #4: atenção, minha acentuação é inoqüa>>teste.txt
hexeditor teste.txt</code></pre>

            <p>Agora temos duas linhas iniciais exibidas corretamente, mas as duas últimas erroneamente. Por quê? Porque ao iniciar o arquivo pela primeira vez, não há indicativos de codepage dentro do arquivo e então o Windows assume que é <code>ANSI</code>.</p>

            <p>Vamos criar as mesmas 4 linhas no Notepad++; note que o mesmo já é criado em <code>UNICODE</code>, mas se olharmos no bloco de notas, notaremos que nenhuma das linhas parece correta porque nem <code>ISO8859_1</code> nem <code>UNICODE</code> são compatíveis com o <code>WIN1252</code> (<code>ANSI</code>).</p>

            <p>Se usarmos o Notepad++ e convertermos o arquivo para <code>UNICODE</code> (Formatar → Codificação UTF-8 ou Europa Ocidental), as duas primeiras ou as duas últimas linhas estão corretas, mas nunca as 4 linhas.</p>

            <h2>Por que não usar <code>UNICODE</code> sempre?</h2>

            <p>Usamos o tempo todo; a Microsoft já se rendeu ao <code>UNICODE</code> no desenvolvimento, embora o Windows ainda tenha uma salada de código de páginas: por exemplo, o sistema de arquivos é <code>UNICODE</code>, o ambiente gráfico ainda é <code>WIN1252</code> e o cmd (terminal) usa <code>ISO8859_1</code>. Por isso, há muitas inconsistências quando programamos em Windows onde a linguagem usa o formato <code>UNICODE</code>. Se um programador abrir um script SQL em formato<code>UNICODE</code> e salvá-lo no disco usando <code>WIN1252</code>, os caracteres serão subvertidos para <code>WIN1252</code> e os que não existirem serão considerados inconsistentes e geralmente mostrados como <code>?</code> e o inverso também é verdadeiro.</p>

            <div class="warning-box">
                <strong>Exemplo prático:</strong> Se você tentar executar um script SQL criado em <code>WIN1252</code> em um banco de dados <code>UNICODE</code> usando o IBExpert, o script aparentemente inofensivo pode não funcionar corretamente.
            </div>

            <p>Isso é um inferno que apenas existe no Windows, e que quando você tentar portar para Linux tem de resolver problemas que antes não existiam. Por isso, para nossa comodidade, os bancos de dados incluem <code>WIN1252</code> entre os seus charsets, embora o mesmo não seja o ideal.</p>

            <h2>Charset e performance em bancos de dados</h2>

            <p>Ainda sobre banco de dados, nem sempre o <code>UNICODE</code> é desejável, pois um único caractere armazenado nele pode ocupar de 1 a 4 bytes. Por isso, não é largamente utilizado se uma aplicação já "fala" <code>ISO8859_1</code> ou <code>WIN1252</code>, pois nações que usam ideogramas ou outros símbolos tipográficos também sabem "falar" <code>ISO8859_1</code> ou <code>WIN1252</code>, embora o inverso não seja verdadeiro. Se você precisar de emojis, símbolo do euro ou ideogramas japoneses na mesma aplicação que usa caracteres ocidentais, só o <code>UNICODE</code> resolveria este problema.</p>

            <p>Então, se você mora num país ocidental que usa os caracteres A-Z, pode-se considerar sortudo porque temos opções de escolha, e geralmente optamos pela mais econômica que também é a mais performática: desconsiderar <code>UNICODE</code> e escolher entre <code>WIN1252</code> ou <code>ISO8859_1</code>.</p>

            <p>Um banco de dados inteiramente em <code>UNICODE</code> é menos performático quando comparado ao <code>ISO8859_1</code>, não apenas por ser mais guloso em termos de espaço — lembre-se, um <code>varchar(64)</code>, a depender do <code>UNICODE</code> usado, ao invés de 64 caracteres pode conter apenas 16 —, mas também porque o algoritmo de "case insensitive" e "accent insensitive" podem vir a ser mais complexos. O MySQL, por exemplo, é reconhecido por adotar uma gambiarra de <code>UNICODE</code> que às vezes cria problemas.</p>

            <h2>Exemplo prático: Criando um banco de teste</h2>

            <p><strong>IBExpert – Criar banco de dados:</strong></p>

            <pre><code>C:\TEMP\TEST_ISO8859_1.FDB
CHARSET: ISO8859_1
COLLATE: PT_BR
ALIAS: TEST_ISO8859_1.FDB
PORTA: 3040</code></pre>

            <h3>Criar a tabela:</h3>

            <pre><code>CREATE TABLE T1(
    FRUTA_ISO8859 VARCHAR(10) CHARACTER SET ISO8859_1 COLLATE PT_BR,
    FRUTA_WIN1252 VARCHAR(10) CHARACTER SET WIN1252 COLLATE WIN_PTBR,
    FRUTA_UNICODE VARCHAR(10) CHARACTER SET UNICODE COLLATE UNICODE_CI_AI
);</code></pre>

            <h3>Popular valores acentuados com o script:</h3>

            <pre><code>INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Maracujá', 'Maracujá', 'Maracujá');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Açaí', 'Açaí', 'Açaí');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Gravatá', 'Gravatá', 'Gravatá');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Avelã', 'Avelã', 'Avelã');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Melão', 'Melão', 'Melão');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Maçã', 'Maçã', 'Maçã');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Mamão', 'Mamão', 'Mamão');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Jiló', 'Jiló', 'Jiló');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Babaçu', 'Babaçu', 'Babaçu');

COMMIT WORK;</code></pre>

            <h3>Verificar tamanho em bytes:</h3>

            <p>Será que todos os caracteres têm o mesmo tamanho em bytes? Execute:</p>

            <pre><code>SELECT
  a.fruta_iso8859||'('||OCTET_LENGTH(a.fruta_iso8859)||')' AS iso8859,
  a.fruta_win1252||'('||OCTET_LENGTH(a.fruta_win1252)||')' AS win1252,
  a.fruta_unicode||'('||OCTET_LENGTH(a.fruta_unicode)||')' AS unicode
FROM T1 a;</code></pre>

            <p>Entre as nossas frutas, o limite de caracteres é 10; o maracujá foi a fruta que mais ocupou espaço em bytes com 9 bytes em <code>UNICODE</code>. O que vai acontecer se aumentarmos para 10 caracteres e acentuarmos ainda mais letras? Vamos conferir:</p>

            <pre><code>UPDATE T1 SET
  FRUTA_UNICODE='Maráçujãío' -- 10 caracteres, deveria caber, o limite é 10
WHERE FRUTA_UNICODE='Maracujá';</code></pre>

            <p>Conseguimos, mas note a divergência entre o tamanho de caracteres e o tamanho de byte ocupados:</p>

            <pre><code>SELECT
  a.fruta_iso8859||OCTET_LENGTH(a.fruta_iso8859),
  a.fruta_win1252||OCTET_LENGTH(a.fruta_win1252),
  a.fruta_unicode||OCTET_LENGTH(a.fruta_unicode)
FROM T1 a
WHERE FRUTA_UNICODE='Maráçujãío';</code></pre>

            <p>Maracujá tem 10 caracteres, mas ocupa agora 14 bytes. Então o tamanho de um campo não é o mesmo que dizer que o tamanho ocupado. O que acha que aconteceria se todas as 10 letras tivessem acento? Vamos tentar:</p>

            <pre><code>UPDATE T1 SET
FRUTA_UNICODE='áéíóúáéíóú' -- 10 caracteres
WHERE FRUTA_UNICODE='Maráçujãío';</code></pre>

            <p>Chegamos então à conclusão de que em <code>UNICODE</code> o armazenamento do seu banco será maior contendo acentuações do que seria em <code>ISO8859_1</code> ou <code>ANSI</code>.</p>

            <h2>Com o armazenamento tão barato, devo me preocupar?</h2>

            <p>Se seu objetivo for internacionalizar, não deve se preocupar com o armazenamento, mas deve se preocupar com os limites teóricos de seus metadados, como nome de objetos. Por exemplo, se eu criar uma tabela cuja chave é um <code>varchar(x)</code> qual é o tamanho máximo de uma chave dentro de um índice?</p>

            <div class="info-box">
                <p><strong>Informação oficial do FirebirdSQL:</strong> No FirebirdSQL, este tamanho é ¼ do tamanho da página de dados. Se por exemplo, seu banco tem páginas de 4KB, significa que o tamanho de um índice não vai poder ultrapassar 1KB então um índice simples ou composto que tenha mais de 1024 bytes não será possível.</p>
                
                <p>A partir do Firebird 2.0, o comprimento máximo de uma string indexada é calculado pela fórmula:</p>
                <pre><code>max_char_length = FLOOR((page_size / 4 - 9) / N)</code></pre>
                <p>onde <em>N</em> é o número de bytes por caractere no charset.</p>
            </div>

            <p>Então, quando estiver usando <code>UNICODE</code>, tome cuidado com os limites do FirebirdSQL que forem em bytes, pois o que antes era 1 byte = 1 caractere não é mais aplicável. Os limites que eram estabelecidos em caracteres, estes não mudam: se o limite para tamanho de nome para uma tabela é 63 caracteres, continuará sendo 63 caracteres, não importando se é <code>UNICODE</code> ou não.</p>

            <p>Aqui temos uma gritante diferença para <code>ISO8859_1</code> ou <code>WIN1252</code>, pois nestes cada caractere é 1 byte, enquanto em <code>UNICODE</code> o FirebirdSQL assume que cada caractere consumido é 4 bytes. Então, se você criar um campo <code>varchar(18000)</code> e inserir 18.000 caracteres acentuados, ele irá deixar, mas o espaço ocupado será 18.000 × 2 ou 18.000 × 4 dependendo do acento.</p>

            <p>Portanto, quando criar um campo que você sabe que no máximo terá X caracteres, leve em consideração:</p>

            <ul>
                <li>O tamanho declarado não é o mesmo que tamanho ocupado.</li>
                <li>Cuidado com os metadados: se um tipo de limite for informado em bytes, então usando <code>UNICODE</code> você terá 4x menos do que o informado.</li>
            </ul>

            <h2>Vamos ao COLLATE</h2>

            <p>Charset é o conjunto de caracteres disponíveis, majoritariamente <code>ISO8859_1</code>, <code>WIN1252</code> e <code>UNICODE</code>. Cada qual com o seu conjunto limitado de caracteres. Se seu banco de dados precisa de caracteres latinos e ocidentais, <code>ISO8859_1</code> está bom para você; você não deveria usar o <code>WIN1252</code> porque ele foi provido apenas para Windows e sua condição pode mudar no futuro.</p>

            <p>Mas se precisa de um conjunto grande de caracteres que permita escrever na mesma sentença caracteres ocidentais, emojis e símbolo do euro, então você tem que optar pelo <code>UNICODE</code>.</p>

            <p>O collate é a forma como os caracteres serão tratados e/ou ordenados. Será que 'A' vem antes de 'á'? Será que 'Pharmacia' e 'Farmacia' são a mesma coisa? Será que 'José' e 'Jose' também são iguais?</p>

            <p>Quem cria os collates define isso. No Brasil não tem essa coisa de 'Ph' de pharmacia dos anos 30, mas em outros países podem haver agrupamento de caracteres (collate) que devam ser tratados conjuntamente e não de forma individual.</p>

            <h3>Exemplo prático de Collate:</h3>

            <pre><code>CREATE TABLE T2 (
    NOME  VARCHAR(30) NOT NULL COLLATE PT_BR
);</code></pre>

            <pre><code>INSERT INTO T2 (NOME) VALUES ('FARMACIA');
INSERT INTO T2 (NOME) VALUES ('FARMÁCIA');
INSERT INTO T2 (NOME) VALUES ('Jose');
INSERT INTO T2 (NOME) VALUES ('José');
INSERT INTO T2 (NOME) VALUES ('JOSÉ');</code></pre>

            <p>Note agora a ordenação de dados entre dois collates diferentes usando o mesmo charset:</p>

            <pre><code>SELECT * FROM T2 a ORDER BY a.nome COLLATE PT_PT;</code></pre>

            <p>Agora o outro:</p>

            <pre><code>SELECT * FROM T2 a ORDER BY a.nome COLLATE PT_BR;</code></pre>

            <p>Os collates estão atrelados ao charset porque sem eles, o banco não teria a regionalidade de ordenação, ou quais sinais diacríticos são iguais a suas versões sem esses sinais e assim por diante.</p>

            <div class="info-box">
                <p><strong>Informação oficial do FirebirdSQL:</strong> O FirebirdSQL suporta vários collations para <code>UNICODE</code>:</p>
                <ul>
                    <li><code>UCS_BASIC</code> - Ordenação binária (posição na tabela)</li>
                    <li><code>UNICODE</code> - Ordenação alfabética usando UCA (Unicode Collation Algorithm)</li>
                    <li><code>UNICODE</code> (binário) - Padrão binário, idêntico ao UCS_BASIC</li>
                    <li><code>UNICODE_CI</code> - Case-insensitive (não diferencia maiúsculas/minúsculas)</li>
                    <li><code>UNICODE_CI_AI</code> - Case-insensitive e accent-insensitive (não diferencia maiúsculas/minúsculas nem acentos)</li>
                </ul>
            </div>

            <p>Mesmo que um banco de dados tenha uma tabela usando 3 <em>charsets</em> diferentes, contendo os mesmos dados, o <em>collate</em> poderá fazer com que os dados se comportem usando a mesma regra linguística. Por exemplo, para o Brasil, <em>case/accent insensitive</em> significa que o <em>collate</em> não fará distinção entre maiúsculos e minúsculos e que a ordenação seguirá um mesmo padrão.</p>

            <h3>Testando ordenação por charset:</h3>

            <p>Vamos testar se a ordenação foi influenciada pelo <em>charset</em> executando esta query:</p>

            <pre><code>EXECUTE BLOCK
RETURNS(
  iso8859_1 VARCHAR(10),
  win1252 VARCHAR(10),
  unicode VARCHAR(10))
AS
BEGIN
  --iso8859_1
  iso8859_1='Sim';
  win1252='-';
  unicode='-';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_iso8859
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
  -- win1252
  iso8859_1='-';
  win1252='Sim';
  unicode='-';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_win1252
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
  -- unicode
  iso8859_1='-';
  win1252='-';
  unicode='Sim';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_unicode
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
END</code></pre>

            <p>Notamos na saída do comando <code>EXECUTE BLOCK</code> que a ordenação pelo charset <code>ISO8859_1</code>, <code>WIN1252</code> ou <code>UNICODE</code> não teve diferença!</p>

            <h3>Inserindo caracteres não acentuados:</h3>

            <p>Vamos complicar e inserir caracteres não acentuados, executando essa sequência de ExecSQL:</p>

            <pre><code>INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Maracuja', 'Maracuja', 'Maracuja');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Açai', 'Açai', 'Açai');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Gravata', 'Gravata', 'Gravata');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Avela', 'Avela', 'Avela');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Melao', 'Melao', 'Melao');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Maça', 'Maça', 'Maça');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Mamao', 'Mamao', 'Mamao');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Jilo', 'Jilo', 'Jilo');
INSERT INTO T1 (FRUTA_ISO8859, FRUTA_WIN1252, FRUTA_UNICODE)
            VALUES ('Babacu', 'Babacu', 'Babacu');</code></pre>

            <p>Executamos o <code>EXECUTE BLOCK</code> outra vez e notamos que não houve diferença, a ordem foi a mesma para todos os casos, apenas a versão não acentuada teve precedência.</p>

            <h2>Resumo e Recomendações</h2>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Charset</th>
                        <th>Bytes por caractere</th>
                        <th>Uso recomendado</th>
                        <th>Vantagens</th>
                        <th>Desvantagens</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>ISO8859_1</strong></td>
                        <td>1 byte</td>
                        <td>Sistemas legados, aplicações brasileiras que não precisam de internacionalização</td>
                        <td>Melhor performance, menor uso de espaço, compatível com padrões ISO</td>
                        <td>Limitado a caracteres latinos ocidentais</td>
                    </tr>
                    <tr>
                        <td><strong>WIN1252</strong></td>
                        <td>1 byte</td>
                        <td>Aplicações Windows que não serão migradas para Linux</td>
                        <td>Melhor performance, menor uso de espaço, inclui símbolo Euro</td>
                        <td>Específico do Windows, problemas em migração para Linux</td>
                    </tr>
                    <tr>
                        <td><strong>UNICODE</strong></td>
                        <td>1-4 bytes</td>
                        <td>Sistemas novos, aplicações internacionais, bancos que precisam suportar múltiplos idiomas</td>
                        <td>Universal, suporta todos os caracteres, padrão moderno</td>
                        <td>Maior uso de espaço, menor performance em alguns casos, complexidade nos índices</td>
                    </tr>
                </tbody>
            </table>

            <h3>Recomendações finais:</h3>
            <ul>
                <li><strong>Para sistemas novos:</strong> Use <code>UNICODE</code>, especialmente se há possibilidade de internacionalização.</li>
                <li><strong>Para sistemas legados brasileiros:</strong> <code>ISO8859_1</code> é a melhor escolha para portabilidade.</li>
                <li><strong>Evite <code>WIN1252</code>:</strong> A menos que você tenha certeza absoluta de que nunca migrará para Linux.</li>
                <li><strong>Atenção aos limites:</strong> Em <code>UNICODE</code>, considere que caracteres acentuados podem ocupar 2-4 bytes, afetando limites de índices.</li>
                <li><strong>Collate adequado:</strong> Escolha o collate apropriado para sua região (PT_BR para Brasil).</li>
            </ul>

            <div class="info-box">
                <p><strong>Referências oficiais:</strong></p>
                <ul>
                    <li><a href="https://firebirdsql.org/refdocs/langrefupd25-ddl-charset.html" target="_blank">FirebirdSQL - CHARACTER SET Documentation</a></li>
                    <li><a href="https://www.firebirdsql.org/file/documentation/chunk/en/refdocs/fblangref40/fblangref40-datatypes-chartypes.html" target="_blank">FirebirdSQL - Character Data Types</a></li>
                    <li><a href="https://www.firebirdsql.org/file/community/ppts/fbcon11/FbCon2011-Charsets-Heymann.pdf" target="_blank">Firebird Conference 2011 - Character Sets and Unicode</a></li>
                </ul>
            </div>

            <p style="margin-top: 3rem;"><a href="sgbd_fb_intro.html" class="back-link">&larr; Voltar para o Guia Firebird</a></p>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Gladiston Santana. São Paulo, Brasil.</p>
    </footer>

</body>
</html>
