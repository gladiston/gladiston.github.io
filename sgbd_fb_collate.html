<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collate e Ordenação - Firebird SQL - Gladiston Santana</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/estilo.css">
</head>
<body>

    <header class="main-header">
        <div class="header-container">
            <img src="assets/img/logo.jpg" alt="Logo" class="logo-circle">
            <div class="header-text">
                <h1>Collate e Ordenação</h1>
                <p>Entendendo como o Firebird compara e ordena caracteres - Guia completo</p>
            </div>
        </div>
    </header>

    <nav class="main-nav">
        <ul class="nav-links">
            <li><a href="index.html">Início</a></li>
            <li><a href="sgbd.html">SGBD Hub</a></li>
            <li><a href="sgbd_fb_intro.html">Firebird</a></li>
        </ul>
    </nav>

    <main>
        <article>
            <h2>O que é Collate?</h2>
            
            <p>Muitos desenvolvedores confundem <strong>Charset</strong> com <strong>Collate</strong>. De forma simples:</p>
            
            <ul>
                <li><strong>Charset:</strong> Define quais caracteres você pode salvar no banco de dados (ISO8859_1, WIN1252, UTF8, etc.)</li>
                <li><strong>Collate:</strong> Define como esses caracteres são comparados e ordenados (ex: se 'A' é igual a 'a', se 'José' é igual a 'Jose', etc.)</li>
            </ul>

            <p>O Collate vive na camada de comparação. Se você precisa que uma busca por "JOAO" retorne "João", você precisa de um collation <em>Case Insensitive</em> (CI) e <em>Accent Insensitive</em> (AI).</p>

            <div class="info-box">
                <p><strong>Relacionamento com Charset:</strong> O collate está sempre atrelado a um charset. Sem o charset, o banco não teria a regionalidade de ordenação, ou quais sinais diacríticos são iguais a suas versões sem esses sinais. Para entender melhor sobre charsets, consulte o artigo <a href="sgbd_fb_charset.html">Qual Charset usar?</a>.</p>
            </div>

            <h2>Por que Collate é importante?</h2>

            <p>Imagine que você tem uma tabela de clientes e precisa fazer uma busca. Sem o collate adequado, você teria que fazer conversões custosas via software (como <code>UPPER()</code> ou <code>LOWER()</code> em todas as queries), o que impede que o banco utilize os índices de forma eficiente.</p>

            <p>O collate define regras como:</p>
            <ul>
                <li>Será que 'A' vem antes de 'á' na ordenação?</li>
                <li>Será que 'Pharmacia' e 'Farmacia' são a mesma coisa?</li>
                <li>Será que 'José' e 'Jose' também são iguais?</li>
                <li>Será que 'A' é igual a 'a' em comparações?</li>
            </ul>

            <p>Quem cria os collates define isso. No Brasil não temos essa coisa de 'Ph' de pharmacia dos anos 30, mas em outros países podem haver agrupamentos de caracteres (collate) que devam ser tratados conjuntamente e não de forma individual.</p>

            <h2>Tipos de Collate: Case e Accent Sensitivity</h2>

            <p>Os collates geralmente são classificados por duas características principais:</p>

            <ul>
                <li><strong>Case Sensitivity (CS/CI):</strong> Se diferencia maiúsculas de minúsculas
                    <ul>
                        <li><strong>CI (Case Insensitive):</strong> 'A' = 'a' (não diferencia maiúsculas/minúsculas)</li>
                        <li><strong>CS (Case Sensitive):</strong> 'A' ≠ 'a' (diferencia maiúsculas/minúsculas)</li>
                    </ul>
                </li>
                <li><strong>Accent Sensitivity (AS/AI):</strong> Se diferencia caracteres acentuados
                    <ul>
                        <li><strong>AI (Accent Insensitive):</strong> 'José' = 'Jose' (não diferencia acentos)</li>
                        <li><strong>AS (Accent Sensitive):</strong> 'José' ≠ 'Jose' (diferencia acentos)</li>
                    </ul>
                </li>
            </ul>

            <h2>Collates disponíveis no Firebird</h2>

            <div class="info-box">
                <p><strong>Collates por Charset no FirebirdSQL:</strong></p>
                <ul>
                    <li><strong>Para UTF8:</strong>
                        <ul>
                            <li><code>UCS_BASIC</code> - Ordenação binária (posição na tabela Unicode)</li>
                            <li><code>UNICODE</code> - Ordenação alfabética usando UCA (Unicode Collation Algorithm)</li>
                            <li><code>UTF8</code> - Padrão binário, idêntico ao UCS_BASIC</li>
                            <li><code>UNICODE_CI</code> - Case-insensitive (não diferencia maiúsculas/minúsculas)</li>
                            <li><code>UNICODE_CI_AI</code> - Case-insensitive e accent-insensitive (não diferencia maiúsculas/minúsculas nem acentos)</li>
                        </ul>
                    </li>
                    <li><strong>Para ISO8859_1:</strong>
                        <ul>
                            <li><code>PT_BR</code> - Português do Brasil (case-sensitive, accent-sensitive)</li>
                            <li><code>PT_PT</code> - Português de Portugal (case-sensitive, accent-sensitive)</li>
                            <li><code>ISO8859_1</code> - Padrão binário</li>
                        </ul>
                    </li>
                    <li><strong>Para WIN1252:</strong>
                        <ul>
                            <li><code>WIN_PTBR</code> - Português do Brasil para Windows (case-sensitive, accent-sensitive)</li>
                            <li><code>WIN1252</code> - Padrão binário</li>
                        </ul>
                    </li>
                </ul>
            </div>

            <h2>Exemplo prático: Criando tabelas com diferentes collates</h2>

            <p><strong>IBExpert – Criar banco de dados:</strong></p>

            <pre><code>C:\TEMP\TEST_COLLATE.FDB
CHARSET: UTF8
COLLATE: UNICODE_CI_AI
ALIAS: TEST_COLLATE.FDB
PORTA: 3040</code></pre>

            <h3>Criar tabela com diferentes collates:</h3>

            <pre><code>CREATE TABLE CLIENTES (
    ID INTEGER NOT NULL PRIMARY KEY,
    NOME_CS_AS VARCHAR(50) CHARACTER SET UTF8 COLLATE UNICODE,  -- Case e Accent Sensitive
    NOME_CI_AS VARCHAR(50) CHARACTER SET UTF8 COLLATE UNICODE_CI,  -- Case Insensitive, Accent Sensitive
    NOME_CI_AI VARCHAR(50) CHARACTER SET UTF8 COLLATE UNICODE_CI_AI,  -- Case e Accent Insensitive
    LOGIN VARCHAR(20) CHARACTER SET UTF8 COLLATE UNICODE_CI_AI  -- Para buscas sem diferenciação
);</code></pre>

            <h3>Inserindo dados de teste:</h3>

            <pre><code>INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (1, 'José', 'José', 'José', 'jose.silva');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (2, 'JOSE', 'JOSE', 'JOSE', 'JOSE.SILVA');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (3, 'Jose', 'Jose', 'Jose', 'jose');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (4, 'Maria', 'Maria', 'Maria', 'maria');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (5, 'MARIA', 'MARIA', 'MARIA', 'MARIA');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (6, 'Farmacia', 'Farmacia', 'Farmacia', 'farmacia');
INSERT INTO CLIENTES (ID, NOME_CS_AS, NOME_CI_AS, NOME_CI_AI, LOGIN)
VALUES (7, 'Farmácia', 'Farmácia', 'Farmácia', 'farmacia2');

COMMIT WORK;</code></pre>

            <h2>Testando comparações com diferentes collates</h2>

            <h3>Teste 1: Busca Case Sensitive vs Case Insensitive</h3>

            <p>Vamos testar se 'Jose' encontra 'JOSE' dependendo do collate:</p>

            <pre><code>-- Busca na coluna Case Sensitive (UNICODE)
SELECT * FROM CLIENTES 
WHERE NOME_CS_AS = 'Jose';
-- Resultado: Apenas o registro com 'Jose' (minúsculo)

-- Busca na coluna Case Insensitive (UNICODE_CI)
SELECT * FROM CLIENTES 
WHERE NOME_CI_AS = 'Jose';
-- Resultado: 'Jose', 'JOSE' e 'José' (encontra variações de maiúsculas/minúsculas)

-- Busca na coluna Case e Accent Insensitive (UNICODE_CI_AI)
SELECT * FROM CLIENTES 
WHERE NOME_CI_AI = 'Jose';
-- Resultado: 'Jose', 'JOSE', 'José' (encontra todas as variações)</code></pre>

            <h3>Teste 2: Busca Accent Sensitive vs Accent Insensitive</h3>

            <p>Vamos testar se 'Farmacia' encontra 'Farmácia':</p>

            <pre><code>-- Busca na coluna Accent Sensitive
SELECT * FROM CLIENTES 
WHERE NOME_CS_AS = 'Farmacia';
-- Resultado: Apenas 'Farmacia' (sem acento)

-- Busca na coluna Accent Insensitive (UNICODE_CI_AI)
SELECT * FROM CLIENTES 
WHERE NOME_CI_AI = 'Farmacia';
-- Resultado: 'Farmacia' e 'Farmácia' (encontra ambas as variações)</code></pre>

            <h3>Teste 3: Ordenação com diferentes collates</h3>

            <p>Vamos ver como a ordenação muda dependendo do collate:</p>

            <pre><code>-- Ordenação Case Sensitive (UNICODE)
SELECT NOME_CS_AS FROM CLIENTES 
ORDER BY NOME_CS_AS;
-- Resultado: Ordena primeiro maiúsculas, depois minúsculas
-- Exemplo: 'FARMACIA', 'JOSE', 'MARIA', 'Farmacia', 'Jose', 'Maria', 'Farmácia', 'José'

-- Ordenação Case Insensitive (UNICODE_CI)
SELECT NOME_CI_AS FROM CLIENTES 
ORDER BY NOME_CI_AS;
-- Resultado: Ignora maiúsculas/minúsculas na ordenação
-- Exemplo: 'Farmacia', 'Farmácia', 'Jose', 'JOSE', 'José', 'Maria', 'MARIA'

-- Ordenação Case e Accent Insensitive (UNICODE_CI_AI)
SELECT NOME_CI_AI FROM CLIENTES 
ORDER BY NOME_CI_AI;
-- Resultado: Ignora maiúsculas/minúsculas e acentos
-- Exemplo: 'Farmacia', 'Farmácia', 'Jose', 'JOSE', 'José', 'Maria', 'MARIA'</code></pre>

            <h2>Exemplo prático: Collate em índices</h2>

            <p>O collate é especialmente importante quando você cria índices. Um índice criado com um collate específico só será usado eficientemente em queries que usam o mesmo collate:</p>

            <pre><code>-- Criar índice com collate Case e Accent Insensitive
CREATE INDEX IDX_CLIENTES_LOGIN ON CLIENTES (LOGIN);

-- Esta query usará o índice eficientemente
SELECT * FROM CLIENTES WHERE LOGIN = 'jose.silva';
-- Funciona porque LOGIN usa UNICODE_CI_AI

-- Mas se você fizer uma busca com collate diferente, o índice pode não ser usado
SELECT * FROM CLIENTES 
WHERE LOGIN COLLATE UNICODE = 'jose.silva';
-- Pode não usar o índice porque o collate é diferente</code></pre>

            <div class="warning-box">
                <strong>Importante:</strong> Quando você especifica um collate diferente na query (usando <code>COLLATE</code> na cláusula WHERE), o banco pode não conseguir usar o índice de forma eficiente. Sempre que possível, use o mesmo collate da coluna nas suas queries.
            </div>

            <h2>Exemplo: Mesmo charset, collates diferentes</h2>

            <p>Vamos ver como o mesmo charset pode ter comportamentos diferentes com collates distintos:</p>

            <pre><code>CREATE TABLE TESTE_COLLATE (
    TEXTO_PT_BR VARCHAR(50) CHARACTER SET UTF8 COLLATE PT_BR,
    TEXTO_PT_PT VARCHAR(50) CHARACTER SET UTF8 COLLATE PT_PT,
    TEXTO_UNICODE VARCHAR(50) CHARACTER SET UTF8 COLLATE UNICODE_CI_AI
);

INSERT INTO TESTE_COLLATE VALUES ('Farmacia', 'Farmacia', 'Farmacia');
INSERT INTO TESTE_COLLATE VALUES ('Farmácia', 'Farmácia', 'Farmácia');
INSERT INTO TESTE_COLLATE VALUES ('José', 'José', 'José');
INSERT INTO TESTE_COLLATE VALUES ('Jose', 'Jose', 'Jose');

-- Ordenação com PT_BR
SELECT TEXTO_PT_BR FROM TESTE_COLLATE ORDER BY TEXTO_PT_BR;
-- Ordenação com PT_PT
SELECT TEXTO_PT_PT FROM TESTE_COLLATE ORDER BY TEXTO_PT_PT;
-- Ordenação com UNICODE_CI_AI
SELECT TEXTO_UNICODE FROM TESTE_COLLATE ORDER BY TEXTO_UNICODE;</code></pre>

            <p>Você notará que a ordenação pode ser diferente entre <code>PT_BR</code> e <code>PT_PT</code>, mesmo usando o mesmo charset UTF8, porque cada collate segue regras linguísticas específicas de sua região.</p>

            <h2>Exemplo prático: Comparando PT_BR e PT_PT</h2>

            <p>Vamos criar uma tabela para demonstrar as diferenças entre collates brasileiro e português:</p>

            <pre><code>CREATE TABLE T2 (
    NOME  VARCHAR(30) NOT NULL COLLATE PT_BR
);

INSERT INTO T2 (NOME) VALUES ('FARMACIA');
INSERT INTO T2 (NOME) VALUES ('FARMÁCIA');
INSERT INTO T2 (NOME) VALUES ('Jose');
INSERT INTO T2 (NOME) VALUES ('José');
INSERT INTO T2 (NOME) VALUES ('JOSÉ');</code></pre>

            <p>Note agora a ordenação de dados entre dois collates diferentes usando o mesmo charset:</p>

            <pre><code>SELECT * FROM T2 a ORDER BY a.nome COLLATE PT_PT;</code></pre>

            <p>Agora o outro:</p>

            <pre><code>SELECT * FROM T2 a ORDER BY a.nome COLLATE PT_BR;</code></pre>

            <p>Os collates estão atrelados ao charset porque sem eles, o banco não teria a regionalidade de ordenação, ou quais sinais diacríticos são iguais a suas versões sem esses sinais e assim por diante.</p>

            <h2>Testando ordenação por charset</h2>

            <p>Mesmo que um banco de dados tenha uma tabela usando 3 <em>charsets</em> diferentes, contendo os mesmos dados, o <em>collate</em> poderá fazer com que os dados se comportem usando a mesma regra linguística. Por exemplo, para o Brasil, <em>case/accent insensitive</em> significa que o <em>collate</em> não fará distinção entre maiúsculos e minúsculos e que a ordenação seguirá um mesmo padrão.</p>

            <p>Vamos testar se a ordenação foi influenciada pelo <em>charset</em> executando esta query (assumindo que você já criou a tabela T1 do exemplo de charset):</p>

            <pre><code>EXECUTE BLOCK
RETURNS(
  iso8859_1 VARCHAR(10),
  win1252 VARCHAR(10),
  unicode VARCHAR(10))
AS
BEGIN
  --iso8859_1
  iso8859_1='Sim';
  win1252='-';
  unicode='-';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_iso8859
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
  -- win1252
  iso8859_1='-';
  win1252='Sim';
  unicode='-';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_win1252
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
  -- unicode
  iso8859_1='-';
  win1252='-';
  unicode='Sim';
  SUSPEND;
  FOR SELECT
    a.fruta_iso8859, a.fruta_win1252, a.fruta_unicode
    FROM T1 a
    ORDER BY a.fruta_unicode
    INTO iso8859_1, win1252, unicode
  DO BEGIN
    SUSPEND;
  END
END</code></pre>

            <p>Notamos na saída do comando <code>EXECUTE BLOCK</code> que a ordenação pelo charset <code>ISO8859_1</code> (latin1), WIN1252 ou unicode não teve diferença! Isso demonstra que o collate padrão de cada charset está fazendo um trabalho similar de ordenação.</p>

            <h2>Recomendações práticas</h2>

            <h3>Quando usar cada tipo de collate:</h3>

            <ul>
                <li><strong>Case e Accent Insensitive (CI_AI) - UNICODE_CI_AI:</strong> 
                    <ul>
                        <li>Campos de login, email, códigos</li>
                        <li>Quando você quer que 'JOAO' encontre 'João'</li>
                        <li>Campos de busca onde o usuário pode digitar sem acentos</li>
                        <li>Campos que precisam de buscas flexíveis</li>
                    </ul>
                </li>
                <li><strong>Case Insensitive, Accent Sensitive (CI_AS) - UNICODE_CI:</strong>
                    <ul>
                        <li>Nomes próprios onde acentos são importantes</li>
                        <li>Quando 'José' deve ser diferente de 'Jose', mas 'JOSE' = 'Jose'</li>
                        <li>Campos onde a diferenciação de acentos é necessária</li>
                    </ul>
                </li>
                <li><strong>Case e Accent Sensitive (CS_AS) - UNICODE, PT_BR, WIN_PTBR:</strong>
                    <ul>
                        <li>Senhas, tokens, códigos exatos</li>
                        <li>Quando a diferenciação exata é crítica</li>
                        <li>Campos onde maiúsculas/minúsculas e acentos importam</li>
                    </ul>
                </li>
                <li><strong>PT_BR ou WIN_PTBR:</strong>
                    <ul>
                        <li>Para aplicações brasileiras que usam ISO8859_1 ou WIN1252</li>
                        <li>Ordenação seguindo regras do português brasileiro</li>
                        <li>Quando você precisa de regionalidade específica</li>
                    </ul>
                </li>
            </ul>

            <h3>Boas práticas:</h3>

            <ul>
                <li><strong>Escolha o collate adequado na criação da tabela:</strong> Evite ter que fazer conversões em todas as queries</li>
                <li><strong>Use o mesmo collate no índice e na coluna:</strong> Para garantir uso eficiente dos índices</li>
                <li><strong>Considere o collate do banco:</strong> Se não especificar, a coluna herdará o collate padrão do banco</li>
                <li><strong>Para aplicações brasileiras:</strong> <code>PT_BR</code> ou <code>UNICODE_CI_AI</code> são geralmente boas escolhas</li>
                <li><strong>Teste as comparações:</strong> Sempre teste se suas queries encontram os dados esperados com o collate escolhido</li>
                <li><strong>Evite usar COLLATE na query:</strong> Se possível, defina o collate correto na coluna ao invés de forçar na query</li>
            </ul>

            <div class="info-box">
                <p><strong>Resumo:</strong> Definir o Collate correto evita que sua aplicação tenha que fazer conversões custosas via software (como <code>UPPER()</code> ou <code>LOWER()</code> em todas as queries), permitindo que o banco utilize os índices de forma eficiente. O collate é uma decisão importante que afeta tanto a performance quanto a funcionalidade das suas queries.</p>
            </div>

            <h2>Collate e Performance</h2>

            <p>O collate escolhido pode impactar a performance das suas queries:</p>

            <ul>
                <li><strong>Collates mais simples (binários):</strong> Geralmente mais rápidos, mas menos flexíveis</li>
                <li><strong>Collates CI_AI:</strong> Podem ser um pouco mais lentos em comparações, mas permitem buscas mais flexíveis sem conversões</li>
                <li><strong>Uso de índices:</strong> Índices criados com um collate específico só serão usados eficientemente em queries que usam o mesmo collate</li>
                <li><strong>Conversões em runtime:</strong> Usar <code>COLLATE</code> na query força conversões em tempo de execução, o que pode ser custoso</li>
            </ul>

            <div class="warning-box">
                <strong>Dica de Performance:</strong> Se você frequentemente precisa fazer buscas case-insensitive ou accent-insensitive, defina o collate adequado na criação da coluna ao invés de usar funções como <code>UPPER()</code> ou <code>LOWER()</code> nas queries. Isso permite que o Firebird use os índices de forma eficiente.
            </div>

            <div class="info-box">
                <p><strong>Referências oficiais:</strong></p>
                <ul>
                    <li><a href="https://firebirdsql.org/refdocs/langrefupd25-ddl-collate.html" target="_blank">FirebirdSQL - COLLATE Documentation</a></li>
                    <li><a href="https://www.firebirdsql.org/file/documentation/chunk/en/refdocs/fblangref40/fblangref40-datatypes-chartypes.html" target="_blank">FirebirdSQL - Character Data Types</a></li>
                    <li><a href="sgbd_fb_charset.html">Qual Charset usar?</a> - Entenda a relação entre Charset e Collate</li>
                    <li><a href="sgbd_collate.html">Guia geral sobre Collate</a> - Comparação entre diferentes SGBDs</li>
                </ul>
            </div>

            <p style="margin-top: 3rem;"><a href="sgbd_fb_intro.html" class="back-link">&larr; Voltar para o Guia Firebird</a></p>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Gladiston Santana. São Paulo, Brasil.</p>
    </footer>

</body>
</html>
