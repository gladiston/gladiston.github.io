<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Queries Parametrizadas - Firebird SQL - Gladiston Santana</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/estilo.css">
</head>
<body>

    <header class="main-header">
        <div class="header-container">
            <img src="assets/img/logo.jpg" alt="Logo" class="logo-circle">
            <div class="header-text">
                <h1>Queries Parametrizadas</h1>
                <p>Por que DBAs insistem que programadores n√£o concatenem strings - Guia completo</p>
            </div>
        </div>
    </header>

    <nav class="main-nav">
        <ul class="nav-links">
            <li><a href="index.html">In√≠cio</a></li>
            <li><a href="sgbd.html">SGBD Hub</a></li>
            <li><a href="sgbd_fb_intro.html">Firebird</a></li>
        </ul>
    </nav>

    <main>
        <article>
            <h2>Por que usar queries parametrizadas?</h2>
            
            <p>Um erro comum entre programadores √© achar que par√¢metros dentro de uma query s√£o como macro-substitui√ß√µes, uma esp√©cie de "Search/Replace" dentro de queries. <strong>Isso n√£o √© verdade.</strong></p>
            
            <p>Par√¢metros s√£o formas de identificar para o servidor SGBD os valores e seus tipos de forma organizada, segura e n√£o sujeita a erros. Al√©m disso, permitem a reutiliza√ß√£o de uma mesma senten√ßa SQL de forma mais perform√°tica.</p>

            <div class="warning-box">
                <strong>Erro comum:</strong> Muitos programadores pensam que par√¢metros s√£o apenas uma forma de substituir valores em strings. Na verdade, par√¢metros s√£o uma forma segura e eficiente de passar dados para o SGBD, com benef√≠cios importantes de seguran√ßa e performance.
            </div>

            <h2>O problema das queries literais (concatena√ß√£o de strings)</h2>

            <p>Muitos programadores preferem usar queries literais, isto √©, concatenando valores diretamente na string SQL. Isso pode parecer mais simples √† primeira vista, mas traz s√©rios problemas de seguran√ßa e performance.</p>

            <h3>Exemplo de query literal (ERRADO):</h3>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Text :=
  'UPDATE CLIENTES SET ' +
  '  RAZAO_SOCIAL = ''' + Trim(edtRazaoSocial.Text) + '''' +
  ' WHERE ID_CLIENTE = ' + edtID_CLIENTE.Text;
Query1.ExecSQL;</code></pre>

            <p>Se a raz√£o social for <strong>INTELIG S/A</strong> e o ID_CLIENTE for 666, a query resultante seria:</p>

            <pre><code>UPDATE CLIENTES SET RAZAO_SOCIAL='INTELIG S/A' WHERE ID_CLIENTE=666</code></pre>

            <p>At√© aqui, parece inofensivo. Mas e se a raz√£o social digitada for <strong>''--INTELIG S/A</strong> (duas aspas simples propositais)? A query resultante seria:</p>

            <pre><code>UPDATE CLIENTES SET RAZAO_SOCIAL=''<strong>--INTELIG S/A' WHERE ID_CLIENTE=666</strong></code></pre>

            <div class="warning-box">
                <strong>üö® SQL Injection:</strong> Os dois tra√ßos (<code>--</code>) em SQL indicam coment√°rio. Isso significa que tudo ap√≥s os tra√ßos ser√° ignorado pelo SGBD. No exemplo acima, a cl√°usula WHERE foi comentada, fazendo com que TODOS os registros da tabela CLIENTES sejam atualizados, n√£o apenas o registro com ID 666!
            </div>

            <h3>Por que QuotedStr() n√£o √© suficiente?</h3>

            <p>Alguns programadores podem pensar: "Vou usar <code>QuotedStr()</code> para resolver o problema das aspas". Embora essa fun√ß√£o resolva parcialmente a quest√£o de aspas simples, ela tem limita√ß√µes importantes:</p>

            <ul>
                <li><strong>Performance:</strong> √â anti-perform√°tica, especialmente com textos longos. Imagine processar um c√≥digo HTML, RTF ou um campo MEMO grande - a fun√ß√£o precisa contar todas as posi√ß√µes das aspas e duplic√°-las.</li>
                <li><strong>Seguran√ßa incompleta:</strong> <code>QuotedStr()</code> n√£o resolve quest√µes envolvendo c√≥digos Unicode, caracteres de escape e outros m√©todos que podem sabotar sua query.</li>
                <li><strong>Manuten√ß√£o:</strong> C√≥digo mais dif√≠cil de manter e propenso a erros.</li>
            </ul>

            <h2>A solu√ß√£o: Queries parametrizadas</h2>

            <p>A solu√ß√£o correta √© usar <strong>par√¢metros</strong> e sinalizar o final da query. Veja o exemplo correto:</p>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('UPDATE CLIENTES SET ');
Query1.SQL.Add('  RAZAO_SOCIAL = :P_RAZAO_SOCIAL');
Query1.SQL.Add('WHERE ID_CLIENTE = :P_ID_CLIENTE');
Query1.SQL.Add(';'); // sinalizando o fim da query
Query1.ParamByName('P_RAZAO_SOCIAL').AsString := Trim(edtRazaoSocial.Text);
Query1.ParamByName('P_ID_CLIENTE').AsInteger := StrToInt(edtID_CLIENTE.Text);
Query1.ExecSQL;</code></pre>

            <div class="info-box">
                <p><strong>Por que usar SQL.Add() ao inv√©s de SQL.Text?</strong> Se voc√™ viu artigos anteriores sobre produtividade na IDE Delphi e Lazarus, deve ter notado o uso de <strong>MultiPaste</strong> ou <strong>Column Mode</strong>. Usando esses recursos, voc√™ escreve a query dentro do editor SQL (IBExpert, FlameRobin, etc.), testa a query, e depois cola na IDE de programa√ß√£o. Usando MultiPaste ou Column Mode, voc√™ gera o c√≥digo de forma r√°pida e organizada.</p>
            </div>

            <p>Com queries parametrizadas, <strong>sob nenhuma hip√≥tese</strong> sua query poder√° ser sabotada pelo tipo de dados informado num formul√°rio. O SGBD trata os par√¢metros de forma segura, separando claramente a estrutura da query dos valores que ser√£o utilizados.</p>

            <h2>Benef√≠cios adicionais: Prepara√ß√£o de queries</h2>

            <p>Queries parametrizadas t√™m ainda outra vantagem importante: caso sejam muito repetitivas em sua aplica√ß√£o, voc√™ pode prepar√°-las uma √∫nica vez e reutiliz√°-las muitas vezes, otimizando o uso em rede.</p>

            <h3>Como funciona a execu√ß√£o de uma query?</h3>

            <p>Quando voc√™ executa uma query, o SGBD passa por v√°rias etapas:</p>

            <ol>
                <li><strong>An√°lise sint√°tica:</strong> Verifica se a sintaxe SQL est√° correta</li>
                <li><strong>Otimiza√ß√£o:</strong> Analisa a melhor forma de executar a query</li>
                <li><strong>C√°lculo de custo:</strong> Avalia o custo de opera√ß√£o com √≠ndices dispon√≠veis</li>
                <li><strong>Compila√ß√£o:</strong> Converte para o formato BLR (Binary Language Representation)</li>
                <li><strong>Execu√ß√£o:</strong> Executa a query e retorna o resultado (se aplic√°vel)</li>
            </ol>

            <p>De todas essas etapas, a mais custosa √© o <strong>PLANO (plan)</strong> para escolher o √≠ndice adequado. Quanto mais √≠ndices existirem, mais tempo levar√° a an√°lise. Isso contradiz um pouco a ideia de que "quanto mais √≠ndices, melhor", n√£o √© mesmo?</p>

            <h3>Exemplo sem prepara√ß√£o:</h3>

            <p>Imagine um sistema de atendimento com mais de 400 pessoas realizando a mesma consulta, apenas com clientes diferentes:</p>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('SELECT status, razao_social, id_cliente FROM CLIENTES');
Query1.SQL.Add('WHERE CNPJ = :P_CNPJ');
Query1.ParamByName('P_CNPJ').AsString := Trim(Pesquisa.Text);
Query1.Open();</code></pre>

            <p>Essa query ser√° executada in√∫meras vezes, passando por todo o processo (an√°lise, otimiza√ß√£o, c√°lculo de custo, compila√ß√£o) a cada consulta. Isso √© muito ineficiente!</p>

            <h3>Exemplo com prepara√ß√£o (CORRETO):</h3>

            <p>H√° uma forma de otimizar isso usando a prepara√ß√£o da query:</p>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('SELECT status, razao_social, cnpj FROM CLIENTES');
Query1.SQL.Add('WHERE ID_CLIENTE = :P_ID_CLIENTE');
if not Query1.Prepared then
  Query1.Prepare;</code></pre>

            <p>O m√©todo <code>Prepare</code> submete a query ao SGBD para "prepara√ß√£o". A query vai at√© a √∫ltima etapa (compila√ß√£o para BLR e cria√ß√£o do plano de execu√ß√£o), mas <strong>n√£o executa</strong>. O SGBD mant√©m o BLR e o PLANO em mem√≥ria, e nas pr√≥ximas execu√ß√µes repetitivas n√£o ser√° necess√°rio passar por todo o processo novamente.</p>

            <div class="info-box">
                <p><strong>E se eu n√£o usar o m√©todo Prepare?</strong> Ferramentas de programa√ß√£o como Delphi e Lazarus fazem infer√™ncia, isto √©, acabam preparando do mesmo jeito, <strong>mas isso pode acontecer num momento inconveniente do programa e mais de uma vez</strong>. √â melhor que voc√™ fa√ßa a prepara√ß√£o num momento bem antes da execu√ß√£o da query, para que o tempo de prepara√ß√£o n√£o se some ao tempo da execu√ß√£o.</p>
            </div>

            <h3>Como o SGBD identifica queries preparadas?</h3>

            <p>O servidor mant√©m na mem√≥ria todas as queries j√° preparadas em forma de <strong>assinatura</strong>:</p>

            <pre><code><strong>SELECT</strong> status, razao_social, cnpj <strong>FROM CLIENTES WHERE ID_CLIENTE = ?</strong></code></pre>

            <p>Esta √© a assinatura. Em alguns SGBDs, os nomes dos campos s√£o irrelevantes. Qualquer query similar √† assinatura ser√° reconhecida imediatamente como uma query preparada.</p>

            <p>N√£o importa de qual esta√ß√£o, programa ou parte do programa venha a query - o que importa √© a assinatura. Se ela for reconhecida, o SGBD usar√° o que j√° foi preparado. Por isso podemos dizer que queries preparadas n√£o beneficiam apenas uma conex√£o/programa, mas muitas conex√µes e muitos programas diferentes onde estatisticamente a mesma consulta acontece.</p>

            <h3>Verificando se a query j√° est√° preparada:</h3>

            <p>Note que fazemos um teste antes de prepar√°-las:</p>

            <pre><code>if not Query1.Prepared then
  Query1.Prepare;</code></pre>

            <p>Por que fazemos isso? Parece √≥bvio, mas se prepararmos todas as vezes, n√£o obteremos a performance que desejamos. A prepara√ß√£o deve ser feita uma √∫nica vez e nunca mais repetida. Mesmo que voc√™ feche o programa e abra de novo, a prepara√ß√£o pode estar l√° em alguma parte da mem√≥ria do SGBD (dependendo de como o SGBD gerencia o cache de queries preparadas).</p>

            <h2>Exemplo pr√°tico: Transfer√™ncias em lote</h2>

            <p>A prepara√ß√£o tamb√©m √© excelente em transfer√™ncias de dados em lote. Veja o exemplo:</p>

            <pre><code>// Primeira query: busca clientes inativos h√° mais de 5 anos
if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('SELECT status, razao_social, cnpj, id_cliente FROM CLIENTES');
Query1.SQL.Add('WHERE ULTIMO_PEDIDO < DATEADD(-5 YEAR TO CURRENT_DATE)');
Query1.Open();

// Segunda query: atualiza status (ser√° executada m√∫ltiplas vezes)
if Query2.Active then
  Query2.Close;
Query2.SQL.Clear;
Query2.SQL.Add('UPDATE CLIENTES SET STATUS = ''C'' ');
Query2.SQL.Add('WHERE ID_CLIENTE = :P_ID_CLIENTE');
if not Query2.Prepared then
  Query2.Prepare;

// Loop processando cada registro
while not Query1.EOF do
begin
  // ... l√≥gica de neg√≥cio ...
  if isPrecisaCancelar then
  begin
    Query2.ParamByName('P_ID_CLIENTE').AsInteger := 
      Query1.FieldByName('ID_CLIENTE').AsInteger;
    Query2.ExecSQL;
  end;  
  Query1.Next;
end;

// Libera recursos quando n√£o for mais usar
if Query2.Prepared then
  Query2.UnPrepare;</code></pre>

            <p>No exemplo acima, a repeti√ß√£o da mesma query √© √≥bvia, ent√£o realizamos a prepara√ß√£o e economizamos tempo significativo. Ao t√©rmino do processo, quando n√£o vamos mais usar a query preparada, executamos <code>UnPrepare</code> para liberar recursos.</p>

            <h3>Quando usar UnPrepare?</h3>

            <p>O <code>UnPrepare</code> faz com que a assinatura da prepara√ß√£o no SGBD seja eliminada, liberando recursos da mem√≥ria do SGBD.</p>

            <div class="info-box">
                <p><strong>Devo fazer sempre o UnPrepare no final?</strong> Quase sempre a resposta √© <strong>"nunca"</strong>. Geralmente s√≥ usamos o <code>UnPrepare</code> em situa√ß√µes de transfer√™ncia de lote de dados, um cen√°rio onde n√£o h√° outros na rede que poderiam se beneficiar de uma query preparada. Um <code>UnPrepare</code> quando outros na rede est√£o se beneficiando de queries repetitivas mataria a performance.</p>
                <p><strong>Regra simples:</strong> Quando a chance √© zero de outros repetirem o mesmo procedimento depois que o mesmo j√° foi executado, ent√£o podemos com tranquilidade chamar o m√©todo <code>UnPrepare</code>. Nos outros cen√°rios, voc√™ nunca ir√° us√°-lo.</p>
            </div>

            <h2>Quando N√ÉO usar prepara√ß√£o</h2>

            <p>Senten√ßas SQL s√£o muito flex√≠veis e cada SGBD tem suas peculiaridades. N√£o √© poss√≠vel descrever todas as situa√ß√µes, mas quando uma senten√ßa √© amb√≠gua para tomada de decis√£o, voc√™ deve evitar uma prepara√ß√£o.</p>

            <h3>Exemplo problem√°tico: LIKE com par√¢metros</h3>

            <p>Com exemplo podemos citar o <code>LIKE</code>. Quando usamos:</p>

            <pre><code>SELECT * FROM CLIENTES
WHERE RAZAO_SOCIAL LIKE 'INDUSTRIA%'</code></pre>

            <p>No exemplo acima, est√° bem claro que se houver um √≠ndice associado √† raz√£o social, o SGBD dever√° us√°-lo. Mas e se a query fosse:</p>

            <pre><code>SELECT * FROM CLIENTES
WHERE RAZAO_SOCIAL LIKE '%INDUSTRIA%'</code></pre>

            <p>Neste novo exemplo, o SGBD ir√° ignorar qualquer √≠ndice, pois n√£o faria sentido us√°-los j√° que todos os registros precisar√£o ser lidos de qualquer forma.</p>

            <p>Agora imagine o que aconteceria se preparasse uma query assim:</p>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('SELECT * FROM CLIENTES');
Query1.SQL.Add('WHERE RAZAO_SOCIAL LIKE :PESQUISA');
if not Query1.Prepared then
  Query1.Prepare;</code></pre>

            <p>Como voc√™ n√£o consegue determinar o que a pessoa digitar√° na barra de pesquisa, vamos imaginar que a primeira pessoa tenha pesquisado por:</p>

            <pre><code>'INDUSTRIA%'</code></pre>

            <p>Como ela √© a primeira pessoa a fazer a prepara√ß√£o, nosso PLANO seria usar um √≠ndice por Raz√£o Social, certo? Sim, isto estaria certo. Mas note que a query j√° foi preparada e h√° no SGBD a assinatura que j√° indicar√° o PLANO a ser executado.</p>

            <p>Da√≠ vem a segunda pessoa e no campo de pesquisa faz a seguinte busca:</p>

            <pre><code>'%INDUSTRIA%'</code></pre>

            <p>Como a query j√° foi preparada, as pesquisas seguintes usar√£o o mesmo PLANO, ou seja, voc√™ for√ßou o uso de um √≠ndice imprest√°vel ao LIKE que s√≥ o far√° perder tempo.</p>

            <div class="warning-box">
                <strong>Aten√ß√£o:</strong> Alguns SGBDs podem detectar a situa√ß√£o acima atrav√©s de probabilidades e estat√≠sticas e agir de forma preditiva, mas √© muito melhor quando programadores evitam situa√ß√µes assim. Hoje um programador pode usar um banco e amanh√£ outro completamente diferente que n√£o seja t√£o preditivo. √â melhor que o desenvolvedor seja mais esperto e n√£o submeta armadilhas ao pr√≥prio SGBD.
            </div>

            <h3>Solu√ß√£o para casos amb√≠guos:</h3>

            <p>Em situa√ß√µes amb√≠guas, evite usar par√¢metro e prefira o <code>QuotedStr()</code> em seu lugar:</p>

            <pre><code>if Query1.Active then
  Query1.Close;
Query1.SQL.Clear;
Query1.SQL.Add('SELECT * FROM CLIENTES');
Query1.SQL.Add('WHERE RAZAO_SOCIAL LIKE ' + QuotedStr(edtPesquisa.Text));</code></pre>

            <p>Neste caso espec√≠fico, como a query muda significativamente dependendo do padr√£o LIKE (com ou sem <code>%</code> no in√≠cio), n√£o faz sentido prepar√°-la. Cada execu√ß√£o ter√° um plano de execu√ß√£o diferente.</p>

            <h2>Resumo das boas pr√°ticas</h2>

            <h3>Sempre use queries parametrizadas quando:</h3>
            <ul>
                <li>Os valores v√™m de entrada do usu√°rio (formul√°rios, campos de texto)</li>
                <li>A estrutura da query √© fixa e apenas os valores mudam</li>
                <li>Voc√™ precisa de seguran√ßa contra SQL Injection</li>
                <li>A query ser√° executada m√∫ltiplas vezes com valores diferentes</li>
            </ul>

            <h3>Use Prepare quando:</h3>
            <ul>
                <li>A query ser√° executada repetidamente na mesma sess√£o</li>
                <li>Voc√™ quer otimizar performance em opera√ß√µes em lote</li>
                <li>A estrutura da query √© est√°vel e n√£o muda</li>
            </ul>

            <h3>‚ùå Evite par√¢metros quando:</h3>
            <ul>
                <li>A query tem estruturas que mudam significativamente (ex: LIKE com padr√µes vari√°veis)</li>
                <li>O plano de execu√ß√£o precisa ser recalculado a cada execu√ß√£o</li>
                <li>A query √© executada apenas uma vez e n√£o ser√° reutilizada</li>
            </ul>

            <h3>‚ùå Nunca use UnPrepare quando:</h3>
            <ul>
                <li>Outros programas/usu√°rios na rede podem se beneficiar da query preparada</li>
                <li>A query ser√° reutilizada frequentemente</li>
                <li>Voc√™ est√° em um ambiente multi-usu√°rio</li>
            </ul>

            <h2>Conclus√£o</h2>

            <p>Tanto os par√¢metros quanto a prepara√ß√£o de uma query n√£o dependem da linguagem de programa√ß√£o, pois este recurso est√° dispon√≠vel em todas elas. Estes recursos servem a um prop√≥sito bem definido: <strong>melhorar seguran√ßa e agilizar pesquisas</strong>.</p>

            <p>Se voc√™ notar que programadores de sua equipe n√£o est√£o usando tais recursos, compartilhe este artigo com eles.</p>

            <p>Cada SGBD √© diferente. Alguns deles subvertem queries mal feitas, outros usam algoritmos para melhorar uma query pouco perform√°tica, mas n√£o se engane: <strong>se programadores forem eficientes na origem da query, o banco ser√° muito mais perform√°tico</strong>. Do contr√°rio, o banco vai ser uma tartaruga obesa com 3 patas.</p>

            <div class="info-box">
                <p><strong>Principais benef√≠cios das queries parametrizadas:</strong></p>
                <ul>
                    <li><strong>Seguran√ßa:</strong> Prote√ß√£o contra SQL Injection</li>
                    <li><strong>Performance:</strong> Possibilidade de prepara√ß√£o e reutiliza√ß√£o</li>
                    <li><strong>Manutenibilidade:</strong> C√≥digo mais limpo e f√°cil de manter</li>
                    <li><strong>Tipagem:</strong> Valida√ß√£o autom√°tica de tipos de dados</li>
                    <li><strong>Efici√™ncia:</strong> Menor uso de recursos do servidor</li>
                </ul>
            </div>

            <p style="margin-top: 3rem;"><a href="sgbd_fb_intro.html" class="back-link">&larr; Voltar para o Guia Firebird</a></p>
        </article>
    </main>

    <footer>
        <p>&copy; 2026 Gladiston Santana. S√£o Paulo, Brasil.</p>
    </footer>

</body>
</html>
